import{_ as a,c as t,o as s,a6 as n}from"./chunks/framework.YF6eQPX_.js";const u=JSON.parse('{"title":"Building a CLI Router for Ink","description":"","frontmatter":{},"headers":[],"relativePath":"dev/cli-router-implementation.md","filePath":"dev/cli-router-implementation.md"}'),i={name:"dev/cli-router-implementation.md"};function o(r,e,l,d,c,p){return s(),t("div",null,[...e[0]||(e[0]=[n(`<h1 id="building-a-cli-router-for-ink" tabindex="-1">Building a CLI Router for Ink <a class="header-anchor" href="#building-a-cli-router-for-ink" aria-label="Permalink to “Building a CLI Router for Ink”">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to “Overview”">​</a></h2><p>This document outlines architectural patterns for implementing a custom CLI router for an Ink-based TUI application. Since Pastel (the Next.js-inspired framework for Ink) is incompatible with Ink v6, we need our own lightweight router that provides:</p><ol><li><strong>CLI argument parsing</strong> - Map shell commands to routes</li><li><strong>In-app navigation</strong> - Navigate between screens with history</li><li><strong>Screen rendering</strong> - Render the correct component for each route</li><li><strong>Dual-mode support</strong> - TUI mode and headless mode for CI/CD</li></ol><h2 id="architecture-comparison" tabindex="-1">Architecture Comparison <a class="header-anchor" href="#architecture-comparison" aria-label="Permalink to “Architecture Comparison”">​</a></h2><h3 id="pastel-s-approach" tabindex="-1">Pastel&#39;s Approach <a class="header-anchor" href="#pastel-s-approach" aria-label="Permalink to “Pastel&#39;s Approach”">​</a></h3><p>Pastel uses file-based routing (like Next.js):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>commands/</span></span>
<span class="line"><span>├── index.tsx           → mycli</span></span>
<span class="line"><span>├── config.tsx          → mycli config</span></span>
<span class="line"><span>└── config/</span></span>
<span class="line"><span>    ├── add.tsx         → mycli config add</span></span>
<span class="line"><span>    └── edit.tsx        → mycli config edit &lt;name&gt;</span></span></code></pre></div><p><strong>Pros:</strong> Convention over configuration, auto-discovery <strong>Cons:</strong> Requires build step, file system coupling, magic</p><h3 id="our-approach-explicit-registry" tabindex="-1">Our Approach: Explicit Registry <a class="header-anchor" href="#our-approach-explicit-registry" aria-label="Permalink to “Our Approach: Explicit Registry”">​</a></h3><p>We use an explicit route registry with meow for CLI parsing:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>src/cli/</span></span>
<span class="line"><span>├── index.tsx           # Entry point + meow setup</span></span>
<span class="line"><span>├── router.tsx          # React context for navigation</span></span>
<span class="line"><span>├── screens.tsx         # Route → Component registry</span></span>
<span class="line"><span>└── screens/</span></span>
<span class="line"><span>    ├── home.tsx</span></span>
<span class="line"><span>    ├── config/</span></span>
<span class="line"><span>    │   ├── list.tsx</span></span>
<span class="line"><span>    │   ├── add.tsx</span></span>
<span class="line"><span>    │   └── edit.tsx</span></span>
<span class="line"><span>    └── ...</span></span></code></pre></div><p><strong>Pros:</strong> Type-safe, explicit, no magic, works with any bundler <strong>Cons:</strong> Manual registration required</p><h2 id="core-concepts" tabindex="-1">Core Concepts <a class="header-anchor" href="#core-concepts" aria-label="Permalink to “Core Concepts”">​</a></h2><h3 id="route-types" tabindex="-1">Route Types <a class="header-anchor" href="#route-types" aria-label="Permalink to “Route Types”">​</a></h3><p>Define a union type of all valid routes for compile-time safety:</p><ul><li>Use string literal unions for route names (e.g., <code>&#39;home&#39; | &#39;config&#39; | &#39;config/add&#39;</code>)</li><li>Consider hierarchical naming with <code>/</code> separators to group related routes</li><li>Define a <code>RouteParams</code> interface for dynamic parameters (name, path, count, etc.)</li><li>Track navigation history as an array of <code>{ route, params }</code> entries</li></ul><h3 id="router-context" tabindex="-1">Router Context <a class="header-anchor" href="#router-context" aria-label="Permalink to “Router Context”">​</a></h3><p>The router should be implemented as a React context that manages:</p><ul><li><strong>Current route</strong> - The active route string</li><li><strong>Route params</strong> - Dynamic parameters for the current route</li><li><strong>History stack</strong> - Previous routes for back navigation</li></ul><p>Key actions to expose:</p><ul><li><code>navigate(route, params)</code> - Push a new route onto history</li><li><code>back()</code> - Pop and navigate to previous route</li><li><code>replace(route, params)</code> - Replace current route without history</li><li><code>reset()</code> - Clear history and return to home</li></ul><p><strong>Deep Route Initialization</strong></p><p>When the CLI starts with a deep route (e.g., <code>noorm settings/secrets/add</code>), the router builds ancestral history automatically. This ensures back navigation works correctly:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Initial route: &#39;settings/secrets/add&#39;</span></span>
<span class="line"><span>Built history: [&#39;home&#39;, &#39;settings&#39;, &#39;settings/secrets&#39;]</span></span></code></pre></div><p>The <code>buildAncestorHistory</code> function uses <code>getParentRoute</code> to walk up the route hierarchy, building the stack so pressing Escape navigates through parents correctly.</p><h3 id="provider-hierarchy" tabindex="-1">Provider Hierarchy <a class="header-anchor" href="#provider-hierarchy" aria-label="Permalink to “Provider Hierarchy”">​</a></h3><p>The app requires a specific nesting order for providers:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>ShutdownProvider      # Lifecycle management, graceful exit</span></span>
<span class="line"><span>└── AppContextProvider    # State/settings orchestration, observer subscriptions</span></span>
<span class="line"><span>    └── ToastProvider     # Toast notifications</span></span>
<span class="line"><span>        └── FocusProvider     # Focus stack management</span></span>
<span class="line"><span>            └── RouterProvider    # Navigation state</span></span>
<span class="line"><span>                └── GlobalKeyboard    # Ctrl+C, Escape handling</span></span>
<span class="line"><span>                    └── AppShell      # Screen rendering</span></span></code></pre></div><p>Key providers:</p><ul><li><strong>ShutdownProvider</strong> - Manages <code>LifecycleManager</code>, provides <code>useShutdown()</code> hook</li><li><strong>AppContextProvider</strong> - Loads state/settings, subscribes to observer events</li><li><strong>ToastProvider</strong> - Toast queue with <code>useToast()</code> hook</li><li><strong>FocusProvider</strong> - Custom focus stack (not Ink&#39;s built-in focus)</li></ul><h3 id="screen-registry" tabindex="-1">Screen Registry <a class="header-anchor" href="#screen-registry" aria-label="Permalink to “Screen Registry”">​</a></h3><p>Map routes to React components using a simple record:</p><ul><li>Consider <code>React.lazy()</code> for code-splitting in larger apps</li><li>Direct imports work fine for smaller CLIs</li><li>Wrap rendering in <code>React.Suspense</code> for lazy-loaded screens</li><li>Handle unknown routes gracefully with an error screen</li></ul><h3 id="cli-entry-point-with-meow" tabindex="-1">CLI Entry Point with meow <a class="header-anchor" href="#cli-entry-point-with-meow" aria-label="Permalink to “CLI Entry Point with meow”">​</a></h3><p>Use <a href="https://github.com/sindresorhus/meow" target="_blank" rel="noreferrer">meow</a> for CLI argument parsing. Meow provides:</p><ul><li>Automatic help text generation</li><li>Flag parsing with type coercion</li><li>Version display from package.json</li><li>camelCase flag conversion</li></ul><p><strong>Pattern: Subcommand Routing</strong></p><p>Since meow doesn&#39;t have built-in subcommand support like Commander, route based on positional arguments:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>mycli                    → input: []           → route: &#39;home&#39;</span></span>
<span class="line"><span>mycli config             → input: [&#39;config&#39;]   → route: &#39;config&#39;</span></span>
<span class="line"><span>mycli config add         → input: [&#39;config&#39;, &#39;add&#39;] → route: &#39;config/add&#39;</span></span>
<span class="line"><span>mycli config edit foo    → input: [&#39;config&#39;, &#39;edit&#39;, &#39;foo&#39;] → route: &#39;config/edit&#39;, params: { name: &#39;foo&#39; }</span></span></code></pre></div><p><strong>Suggested approach:</strong></p><ol><li>Parse <code>cli.input</code> array to determine the route</li><li>Extract remaining positional args as route parameters</li><li>Pass <code>cli.flags</code> as additional context (headless mode, verbose, etc.)</li><li>Start the app with resolved route and params</li></ol><h2 id="advanced-patterns" tabindex="-1">Advanced Patterns <a class="header-anchor" href="#advanced-patterns" aria-label="Permalink to “Advanced Patterns”">​</a></h2><h3 id="global-keyboard-handler" tabindex="-1">Global Keyboard Handler <a class="header-anchor" href="#global-keyboard-handler" aria-label="Permalink to “Global Keyboard Handler”">​</a></h3><p>Add consistent keyboard shortcuts across all screens:</p><ul><li><code>q</code> to quit the application</li><li><code>Escape</code> to go back (when history exists)</li><li>Consider a wrapper component that uses Ink&#39;s <code>useInput</code> hook</li><li>Prevent duplicate handlers by managing focus appropriately</li></ul><p>Available keyboard helper hooks in <code>src/cli/keyboard.tsx</code>:</p><ul><li><strong><code>useFocusedInput(isFocused, handler)</code></strong> - Wraps <code>useInput</code> with focus checking</li><li><strong><code>useListKeys(options)</code></strong> - List navigation (up/down, enter selection)</li><li><strong><code>useQuitHandler()</code></strong> - Graceful shutdown on Ctrl+C</li></ul><h3 id="headless-mode-for-ci-cd" tabindex="-1">Headless Mode for CI/CD <a class="header-anchor" href="#headless-mode-for-ci-cd" aria-label="Permalink to “Headless Mode for CI/CD”">​</a></h3><p>Support non-interactive execution for scripts and CI pipelines:</p><ul><li>Detect headless mode via <code>process.env.CI</code> or <code>!process.stdout.isTTY</code></li><li>Allow explicit <code>--headless</code> flag override</li><li>In headless mode, execute commands directly and output JSON/text to stdout</li><li>Skip TUI rendering entirely in headless mode</li></ul><h3 id="route-guards" tabindex="-1">Route Guards <a class="header-anchor" href="#route-guards" aria-label="Permalink to “Route Guards”">​</a></h3><p>Add logic that runs before navigation:</p><ul><li>Validate required params exist before allowing navigation</li><li>Redirect to fallback routes when guards fail</li><li>Useful for routes that require a selected config or authenticated state</li></ul><h3 id="section-based-navigation" tabindex="-1">Section-Based Navigation <a class="header-anchor" href="#section-based-navigation" aria-label="Permalink to “Section-Based Navigation”">​</a></h3><p>Group routes by section for tab-style navigation:</p><ul><li>Extract section from route string (e.g., <code>&#39;config/add&#39;</code> → section: <code>&#39;config&#39;</code>)</li><li>Enable parent route navigation (e.g., <code>&#39;config/add&#39;</code> → parent: <code>&#39;config&#39;</code>)</li><li>Useful for breadcrumb-style navigation or tab highlighting</li></ul><h2 id="file-structure" tabindex="-1">File Structure <a class="header-anchor" href="#file-structure" aria-label="Permalink to “File Structure”">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>src/cli/</span></span>
<span class="line"><span>├── index.tsx              # Entry point, meow setup</span></span>
<span class="line"><span>├── app.tsx                # Root App component</span></span>
<span class="line"><span>├── router.tsx             # Router context and hooks</span></span>
<span class="line"><span>├── screens.tsx            # Route → Component registry</span></span>
<span class="line"><span>├── keyboard.tsx           # Global keyboard handler</span></span>
<span class="line"><span>├── types.ts               # Type definitions</span></span>
<span class="line"><span>└── screens/</span></span>
<span class="line"><span>    ├── home.tsx</span></span>
<span class="line"><span>    ├── config/</span></span>
<span class="line"><span>    │   ├── list.tsx</span></span>
<span class="line"><span>    │   ├── add.tsx</span></span>
<span class="line"><span>    │   ├── edit.tsx</span></span>
<span class="line"><span>    │   └── rm.tsx</span></span>
<span class="line"><span>    └── ...</span></span></code></pre></div><h2 id="comparison-our-router-vs-pastel" tabindex="-1">Comparison: Our Router vs Pastel <a class="header-anchor" href="#comparison-our-router-vs-pastel" aria-label="Permalink to “Comparison: Our Router vs Pastel”">​</a></h2><table tabindex="0"><thead><tr><th>Feature</th><th>Pastel</th><th>Our Router</th></tr></thead><tbody><tr><td>Route Definition</td><td>File-based (magic)</td><td>Explicit registry</td></tr><tr><td>Type Safety</td><td>Zod schemas</td><td>TypeScript unions</td></tr><tr><td>CLI Parsing</td><td>Built-in</td><td>meow</td></tr><tr><td>Ink Version</td><td>v4 only</td><td>v6 compatible</td></tr><tr><td>Code Splitting</td><td>Automatic</td><td>Manual (React.lazy)</td></tr><tr><td>Build Step</td><td>Required</td><td>Optional</td></tr><tr><td>Learning Curve</td><td>Next.js familiar</td><td>React Router familiar</td></tr><tr><td>Bundle Size</td><td>Larger</td><td>Minimal</td></tr></tbody></table><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to “Alternatives Considered”">​</a></h2><p>Other approaches were evaluated but didn&#39;t fit our requirements:</p><ul><li><strong>React Router / Wouter</strong> - URL-based routing doesn&#39;t map well to CLI navigation</li><li><strong>XState</strong> - Better suited for multi-step workflows within a single screen, overkill for screen navigation</li><li><strong>Pastel</strong> - May eventually support Ink v6, but building our own gives full control without external dependency risk</li></ul><h2 id="considerations" tabindex="-1">Considerations <a class="header-anchor" href="#considerations" aria-label="Permalink to “Considerations”">​</a></h2><h3 id="complexity-factors" tabindex="-1">Complexity Factors <a class="header-anchor" href="#complexity-factors" aria-label="Permalink to “Complexity Factors”">​</a></h3><table tabindex="0"><thead><tr><th>Component</th><th>Notes</th></tr></thead><tbody><tr><td>Types</td><td>Union types, params interface</td></tr><tr><td>Router Context</td><td>State management, history stack</td></tr><tr><td>Screen Registry</td><td>Lazy loading optional</td></tr><tr><td>meow Setup</td><td>Subcommand parsing from input</td></tr><tr><td>Global Keyboard</td><td>Ink useInput integration</td></tr><tr><td>Headless Mode</td><td>Alternative execution path</td></tr></tbody></table><p>Most effort goes into:</p><ol><li>Writing individual screen components</li><li>Defining the route-to-input mapping logic</li><li>Implementing headless command handlers (if needed)</li></ol><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to “Conclusion”">​</a></h2><p>Building a custom router for Ink v6 is a pragmatic choice that:</p><ul><li>Keeps dependencies minimal</li><li>Provides full type safety</li><li>Supports both TUI and headless modes</li><li>Requires no build-time magic</li><li>Is simple enough to understand and maintain</li></ul><p>The router infrastructure is lightweight, with most complexity in the screen components themselves.</p>`,73)])])}const g=a(i,[["render",o]]);export{u as __pageData,g as default};
