import{_ as e,c as i,o as a,a6 as t}from"./chunks/framework.YF6eQPX_.js";const k=JSON.parse(`{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"noorm","text":"SQL defines the truth. Everything else builds on top.","tagline":"Express what ORMs can't. Compound keys, check constraints, triggers, stored procedures—real SQL.","image":{"src":"/image/0105.gif","alt":"noorm TUI demo"},"actions":[{"theme":"brand","text":"Get Started","link":"/getting-started/installation"},{"theme":"alt","text":"View on GitHub","link":"https://github.com/noormdev/noorm"}]},"features":[{"icon":{"src":"/icons/bolt.svg"},"title":"No Migration Sprawl","details":"Fresh databases don't replay 3 years of history. Run your SQL files directly and get the current schema. Test databases rebuild in seconds."},{"icon":{"src":"/icons/code-branch.svg"},"title":"See Current State","details":"SQL files show what IS, not archaeology of what WAS. Open a file, see the schema. No tracing through 200 migrations to understand a table."},{"icon":{"src":"/icons/flask.svg"},"title":"Raw SQL Power","details":"Compound keys, complex constraints, proper relational modeling. Write the schema ORMs won't let you express."},{"icon":{"src":"/icons/terminal.svg"},"title":"Built-in Tools","details":"Schema explorer, SQL terminal, dynamic templates, encrypted secrets. Full database management without leaving your terminal."}]},"headers":[],"relativePath":"index.md","filePath":"index.md"}`),n={name:"index.md"};function l(r,s,o,p,h,d){return a(),i("div",null,[...s[0]||(s[0]=[t(`<h2 id="why-noorm" tabindex="-1">Why noorm? <a class="header-anchor" href="#why-noorm" aria-label="Permalink to “Why noorm?”">​</a></h2><p><strong>noorm is NOT an ORM.</strong> ORMs replace your SQL with inefficient abstractions. noorm runs your SQL directly.</p><p>Raw SQL lets you design databases properly. Inherited keys, base/subtype hierarchies, complex constraints—the relational model as it was intended.</p><p>noorm makes it manageable. SQL files define your schema. Changes evolve existing databases. Execution tracking, environment configs, encrypted secrets, team collaboration—all handled from your terminal. You focus on the SQL.</p><h3 id="the-case-for-proper-relational-design" tabindex="-1">The Case for Proper Relational Design <a class="header-anchor" href="#the-case-for-proper-relational-design" aria-label="Permalink to “The Case for Proper Relational Design”">​</a></h3><p>ORMs push you toward a pattern: every table gets a surrogate ID, relationships happen through foreign keys, and you join your way back to find what you need. It works—until you&#39;re seven joins deep trying to figure out which user owns a deeply nested entity, and your messy left joins are adding NULL rows or creating cartesian products.</p><p>Proper relational design uses <strong>inherited keys</strong>. Instead of giving every entity an independent identity, child entities inherit their parent&#39;s key as part of their own.</p><p><strong>Example: A todo list</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>users</span></span>
<span class="line"><span>  → user_id (surrogate, this is the root)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>todos</span></span>
<span class="line"><span>  → user_id + created_at (inherits from user, no separate todo_id)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>todo_items</span></span>
<span class="line"><span>  → user_id + created_at + item_index (inherits from todo)</span></span></code></pre></div><p>With inherited keys, a <code>todo_item</code> carries its lineage in its identity. You don&#39;t need joins to find the user—it&#39;s right there in the key. The deeper your schema goes, the more this matters.</p><p><em>Try working that into your ORM. I&#39;ll wait...</em></p><h3 id="furthermore-polymorphism-basetype-subtypes" tabindex="-1">Furthermore: <s>Polymorphism</s> Basetype-Subtypes <a class="header-anchor" href="#furthermore-polymorphism-basetype-subtypes" aria-label="Permalink to “Furthermore: Polymorphism Basetype-Subtypes”">​</a></h3><p>ORMs love polymorphic associations: a <code>comments</code> table with <code>commentable_type</code> and <code>commentable_id</code>. Fast, flexible—and completely breaks referential integrity. Complex app logic, no foreign keys, slow and awkward statistics, and even more awkward queries.</p><p>Proper relational design solved this years ago with <strong>basetype-subtypes</strong>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>independent entities: user, group</span></span>
<span class="line"><span>dependent entities:   profile</span></span>
<span class="line"><span>basetype-subtypes:    post     → user_post, group_post</span></span>
<span class="line"><span>                      photo    → user_photo, group_photo, profile_photo, user_post_photo, ...</span></span>
<span class="line"><span>                      comment  → user_comment, group_comment, post_comment, comment_comment, ...</span></span>
<span class="line"><span>                      tag      → post_tag, photo_tag, comment_tag, ...</span></span></code></pre></div><p>Each relationship gets its own table with proper constraints against its parent. A <code>user_post</code> has a foreign key to <code>user</code> and <code>post</code>. A <code>group_photo</code> has a foreign key to <code>group</code> and <code>photo</code>. No nulls, no type columns, no ambiguity.</p><p>You work with existence and non-existence—not &quot;maybe exists&quot; or calculate. You depend on physical existence, not hopeful logic. Statistics are straightforward. Queries are clean. The database enforces integrity at every level. Illegal states become impossible. The trade-off is more tables, but the benefit is less app logic.</p><p>You pay for bad relational design later in complexity and bugs.</p><h2 id="quick-start" tabindex="-1">Quick Start <a class="header-anchor" href="#quick-start" aria-label="Permalink to “Quick Start”">​</a></h2><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Install</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @noormdev/cli</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Launch the TUI</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span></span></code></pre></div><p>From the terminal interface, set up your project:</p><ol><li><strong>[i] Identity</strong> — Set your name (for team tracking)</li><li><strong>[c] Config → [a] Add</strong> — Create a database config</li><li><strong>[r] Run → Build</strong> — Execute your SQL files</li></ol><p>Or use headless mode for scripting:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> init</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> identity</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Your Name&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span></code></pre></div><p>Create your SQL files:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sql/01_tables</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT);&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sql/01_tables/001_users.sql</span></span></code></pre></div><p>Build your schema:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>✓ Executed 1 file</span></span></code></pre></div><p>Now your schema needs to evolve. Update your SQL file AND create a change:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Update sql/01_tables/001_users.sql (add email column)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create changes/2024-01-add-email/forward.sql</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> change</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ff</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # Fast-forward: apply pending changes</span></span></code></pre></div><p>Need a fresh test database? Create another config and build—no changes needed:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Create test config</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # Fresh DB gets current schema directly</span></span></code></pre></div><p><strong>SQL files = current schema. Changes = how to get existing databases there.</strong></p><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to “Next Steps”">​</a></h2><div class="next-steps"><p><a href="/getting-started/installation.html"><strong>Installation</strong></a> Get noorm installed and running in 2 minutes.</p><p><a href="/getting-started/first-build.html"><strong>First Build</strong></a> Complete the 5-minute tutorial and see the core value prop.</p><p><a href="/getting-started/concepts.html"><strong>Concepts</strong></a> Understand the mental model behind noorm.</p></div>`,36)])])}const g=e(n,[["render",l]]);export{k as __pageData,g as default};
