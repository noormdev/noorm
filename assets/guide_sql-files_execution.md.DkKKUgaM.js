import{_ as s,c as a,o as t,a6 as i}from"./chunks/framework.YF6eQPX_.js";const u=JSON.parse('{"title":"Execution","description":"","frontmatter":{},"headers":[],"relativePath":"guide/sql-files/execution.md","filePath":"guide/sql-files/execution.md"}'),n={name:"guide/sql-files/execution.md"};function d(l,e,r,o,c,h){return t(),a("div",null,[...e[0]||(e[0]=[i(`<h1 id="execution" tabindex="-1">Execution <a class="header-anchor" href="#execution" aria-label="Permalink to “Execution”">​</a></h1><h2 id="how-execution-works" tabindex="-1">How Execution Works <a class="header-anchor" href="#how-execution-works" aria-label="Permalink to “How Execution Works”">​</a></h2><p>When you run SQL files with noorm, every file goes through a checksum-based change detection process. This is the core value proposition: files that haven&#39;t changed don&#39;t run again.</p><p>Here&#39;s what happens under the hood:</p><ol><li>noorm computes a SHA-256 checksum of the file contents</li><li>It checks the tracking database for a previous execution record</li><li>If the file is new, changed, or previously failed, it runs</li><li>If unchanged and successful, it&#39;s skipped</li><li>After execution, the result and new checksum are recorded</li></ol><p>This makes builds idempotent. Run the same command twice—unchanged files won&#39;t re-execute.</p><h2 id="run-build" tabindex="-1">run build <a class="header-anchor" href="#run-build" aria-label="Permalink to “run build”">​</a></h2><p>The primary command for executing your schema:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span></code></pre></div><p>This executes all SQL files in your schema directory (defined in settings). Files are processed alphabetically by path, which means you can control execution order with prefixes:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>sql/</span></span>
<span class="line"><span>├── 00_extensions/</span></span>
<span class="line"><span>│   └── 001_extensions.sql        # Runs first</span></span>
<span class="line"><span>├── 01_tables/</span></span>
<span class="line"><span>│   ├── 001_users.sql             # Runs second</span></span>
<span class="line"><span>│   └── 002_posts.sql             # Runs third</span></span>
<span class="line"><span>└── 02_views/</span></span>
<span class="line"><span>    └── 001_active_users.sql      # Runs last</span></span></code></pre></div><p>Output shows what ran and what was skipped:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Building schema...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>✓ sql/01_tables/001_users.sql</span></span>
<span class="line"><span>• sql/01_tables/002_posts.sql (unchanged)</span></span>
<span class="line"><span>✓ sql/02_views/001_active_users.sql</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Executed: 2</span></span>
<span class="line"><span>Skipped:  1</span></span></code></pre></div><h2 id="run-file" tabindex="-1">run file <a class="header-anchor" href="#run-file" aria-label="Permalink to “run file”">​</a></h2><p>Execute a single SQL file:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sql/01_tables/001_users.sql</span></span></code></pre></div><p>Useful for testing a specific file or re-running one file after a quick fix. The same change detection applies—if the file hasn&#39;t changed since its last successful run, it won&#39;t execute unless you use <code>--force</code>.</p><h2 id="run-dir" tabindex="-1">run dir <a class="header-anchor" href="#run-dir" aria-label="Permalink to “run dir”">​</a></h2><p>Execute all files in a specific directory:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sql/02_views</span></span></code></pre></div><p>Processes all <code>.sql</code> and <code>.sql.tmpl</code> files in that directory (and subdirectories), alphabetically. This is helpful when you want to rebuild just views or just a subset of your schema.</p><h2 id="force-mode" tabindex="-1">Force Mode <a class="header-anchor" href="#force-mode" aria-label="Permalink to “Force Mode”">​</a></h2><p>Skip change detection entirely with <code>--force</code>:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --force</span></span></code></pre></div><p>Every file executes, regardless of whether it changed. Use this when:</p><ul><li>You need to rebuild everything after a database restore</li><li>Troubleshooting an issue and want fresh execution</li><li>External changes happened that noorm doesn&#39;t know about</li></ul><p>In the TUI, the force option appears when you select a run command.</p><h2 id="dry-run-mode" tabindex="-1">Dry Run Mode <a class="header-anchor" href="#dry-run-mode" aria-label="Permalink to “Dry Run Mode”">​</a></h2><p>Preview what would execute without actually running anything:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">noorm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --dry-run</span></span></code></pre></div><p>This renders all SQL files (including templates) and writes them to a local <code>tmp/</code> directory that mirrors your source structure:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Source:                              Dry run output:</span></span>
<span class="line"><span>sql/02_views/001_my_view.sql  →   tmp/sql/02_views/001_my_view.sql</span></span>
<span class="line"><span>sql/03_seeds/001_users.sql.tmpl  →   tmp/sql/03_seeds/001_users.sql</span></span></code></pre></div><p>Templates are fully rendered with your current config context. The <code>.tmpl</code> extension is stripped from output files.</p><p><strong>When to use dry run:</strong></p><table tabindex="0"><thead><tr><th>Scenario</th><th>Command</th></tr></thead><tbody><tr><td>Inspect rendered templates</td><td><code>noorm run build --dry-run</code></td></tr><tr><td>Review before production deploy</td><td><code>noorm run build --dry-run -c production</code></td></tr><tr><td>Debug template variables</td><td><code>noorm run file seed.sql.tmpl --dry-run</code></td></tr><tr><td>CI/CD validation step</td><td><code>noorm run build --dry-run</code></td></tr></tbody></table><h2 id="what-gets-tracked" tabindex="-1">What Gets Tracked <a class="header-anchor" href="#what-gets-tracked" aria-label="Permalink to “What Gets Tracked”">​</a></h2><p>noorm maintains two tables in your database to track execution history:</p><p><strong><code>__noorm_change__</code></strong> - Operation records:</p><table tabindex="0"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></td><td>Operation identifier (e.g., <code>build:2024-01-15T10:30:00</code>)</td></tr><tr><td><code>change_type</code></td><td><code>&#39;build&#39;</code> or <code>&#39;run&#39;</code></td></tr><tr><td><code>executed_by</code></td><td>Identity string (who ran it)</td></tr><tr><td><code>config_name</code></td><td>Which config was used</td></tr><tr><td><code>status</code></td><td><code>&#39;pending&#39;</code>, <code>&#39;success&#39;</code>, <code>&#39;failed&#39;</code></td></tr></tbody></table><p><strong><code>__noorm_executions__</code></strong> - Individual file records:</p><table tabindex="0"><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>change_id</code></td><td>FK to parent operation</td></tr><tr><td><code>filepath</code></td><td>File that was executed</td></tr><tr><td><code>checksum</code></td><td>SHA-256 of file contents</td></tr><tr><td><code>status</code></td><td><code>&#39;success&#39;</code>, <code>&#39;failed&#39;</code>, <code>&#39;skipped&#39;</code></td></tr><tr><td><code>skip_reason</code></td><td><code>&#39;unchanged&#39;</code> if skipped</td></tr><tr><td><code>duration_ms</code></td><td>Execution time</td></tr></tbody></table><p>These tables let noorm answer: &quot;Has this exact file content been executed before, and did it succeed?&quot;</p><h2 id="execution-order" tabindex="-1">Execution Order <a class="header-anchor" href="#execution-order" aria-label="Permalink to “Execution Order”">​</a></h2><p>Files execute <strong>alphabetically by full path</strong>. This is deterministic and predictable, but it means you need to name files carefully when order matters. See <a href="/guide/sql-files/organization.html">Organization</a> for detailed naming strategies.</p><p>Common patterns:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>sql/</span></span>
<span class="line"><span>├── 00_extensions/</span></span>
<span class="line"><span>│   └── 001_uuid.sql           # Extensions first</span></span>
<span class="line"><span>├── 01_types/</span></span>
<span class="line"><span>│   └── 001_enums.sql          # Types before tables</span></span>
<span class="line"><span>├── 02_tables/</span></span>
<span class="line"><span>│   ├── 001_users.sql          # Independent tables first</span></span>
<span class="line"><span>│   ├── 002_profiles.sql       # Tables with FKs after their dependencies</span></span>
<span class="line"><span>│   └── 003_posts.sql</span></span>
<span class="line"><span>└── 03_views/</span></span>
<span class="line"><span>    └── 001_active_users.sql   # Views last (they depend on tables)</span></span></code></pre></div><p>The numbered prefixes ensure:</p><ol><li>Extensions load before anything uses them</li><li>Types exist before tables reference them</li><li>Tables exist before views reference them</li><li>Within each category, files run in predictable order</li></ol><div class="tip custom-block"><p class="custom-block-title">File Naming</p><p>Use <code>001_</code>, <code>002_</code> prefixes rather than <code>1_</code>, <code>2_</code> for consistent sorting. Leading zeros ensure <code>002</code> comes before <code>010</code> alphabetically.</p></div><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to “Summary”">​</a></h2><table tabindex="0"><thead><tr><th>Command</th><th>Purpose</th></tr></thead><tbody><tr><td><code>noorm run build</code></td><td>Execute entire schema directory</td></tr><tr><td><code>noorm run file &lt;path&gt;</code></td><td>Execute single file</td></tr><tr><td><code>noorm run dir &lt;path&gt;</code></td><td>Execute files in directory</td></tr><tr><td><code>--force</code></td><td>Re-run regardless of changes</td></tr><tr><td><code>--dry-run</code></td><td>Preview without executing</td></tr></tbody></table><p>The checksum system means you can run <code>noorm run build</code> as often as you want—only changed or new files execute. This is the foundation of noorm&#39;s approach to database schema management.</p><h2 id="what-s-next" tabindex="-1">What&#39;s Next? <a class="header-anchor" href="#what-s-next" aria-label="Permalink to “What&#39;s Next?”">​</a></h2><ul><li><a href="/guide/sql-files/organization.html">Organization</a> - Structure your SQL files for predictable execution order</li><li><a href="/guide/sql-files/templates.html">Templates</a> - Add dynamic content to <code>.sql.tmpl</code> files</li><li><a href="/guide/changes/overview.html">Changes</a> - One-time operations with rollback support</li></ul>`,54)])])}const g=s(n,[["render",d]]);export{u as __pageData,g as default};
